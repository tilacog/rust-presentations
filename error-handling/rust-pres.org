#+TITLE:     Handle Errors in Rust
#+AUTHOR:    Tiago Guimar√£es
#+EMAIL:     tilacog@protonmail.com
#+DATE:      2021-03-10 Wed
#+OPTIONS: num:nil toc:nil
#+REVEAL_ROOT: file:///home/tilacog/tiago/code/others/reveal.js-4.1.0
#+REVEAL_HLEVEL: 2

#+REVEAL_INIT_OPTIONS: width:1800

* Handle Errors in Rust
** Introduction
[[https://play.rust-lang.org][Rust Playground]]
** Panic
*** fatal errors
#+begin_src rust
fn main() {
    panic!("Farewell!");
}
#+end_src

*** out of bounds array access
#+begin_src rust
fn main() {
    let v = vec![0, 1, 2, 3];
    println!("{}", v[6]); // this will cause a panic!
}
#+end_src

** Option

*** The =Option= type
#+begin_src rust
enum Option<T> {
    None,     // No element was found
    Some(T),  // An element of type T was found
}
#+end_src

*** Using =Option= on collections
#+begin_src rust
fn main() {
    let fruits = ["banana", "apple", "coconut", "orange", "strawberry"];

    // pick the first item:
    let first = fruits.get(0);
    println!("{:?}", first);

    // pick the third item:
    let third = fruits.get(2);
    println!("{:?}", third);

    // pick the 99th item, which is non-existent:
    let non_existent = fruits.get(99);
    println!("{:?}", non_existent);
}
#+end_src

*** Pattern Matching
#+begin_src rust
fn main() {
    let fruits = vec!["banana", "apple", "coconut", "orange", "strawberry"];

    for &index in [0, 2, 99].iter() {
        match fruits.get(index) {
            Option::Some(fruit_name) => println!("It's a delicious {}!", fruit_name),
            Option::None => println!("There is no fruit! :("),
        }
    }
}
#+end_src

*** Pattern Matching
#+begin_src rust
fn main() {
    let fruits = vec!["banana", "apple", "coconut", "orange", "strawberry"];
    for &index in [0, 2, 99].iter() {
        match fruits.get(index) {
            Some(&"coconut") => println!("Coconuts are awesome!!!"),
            Some(fruit_name) => println!("It's a delicious {}!", fruit_name),
            None => println!("There is no fruit! :("),
        }
    }
}
#+end_src

*** =if let=
#+begin_src rust
// ugly code
let some_number: Option<u8> = Some(7);
match some_number {
    Some(7) => println!("That's my lucky number!"),
    _ => (),
}
#+end_src

*** =if let=
#+begin_src rust
// beautiful code
let some_number: Option<u8> = Some(7);
if let Some(7) = some_u8_value {
    println!("That's my lucky number!");
}
#+end_src

*** unwrap and expect
#+begin_src rust
let gift = Some("candy");
assert_eq!(gift.unwrap(), "candy");

let empty_gift: Option<&str> = None;
assert_eq!(empty_gift.unwrap(), "candy"); // This will panic!
#+end_src

*** expect
#+begin_src rust
let a = Some("banana");
assert_eq!(a.expect("not a banana!"), "banana");

let b: Option<&str> = None;
b.expect("where are my bananas?"); // panics with `fruits are healthy`
#+end_src

*** unwrap_or
#+begin_src rust
assert_eq!(Some("dog").unwrap_or("cat"), "dog");
assert_eq!(None.unwrap_or("cat"), "cat");
#+end_src

** Result

*** first slide
#+begin_src rust

#+end_src
